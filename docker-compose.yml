version: '3.8'

volumes:
  aethercast_db_data: # This might become unused if all services switch to Postgres
  aethercast_audio_data:
  postgres_data: # New volume for PostgreSQL data

services:
  postgres_db:
    image: postgres:15-alpine
    container_name: aethercast_postgres_db
    ports:
      - "5432:5432"
    environment:
      POSTGRES_USER: ${POSTGRES_USER:-aethercastuser}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-aethercastpass}
      POSTGRES_DB: ${POSTGRES_DB:-aethercast_db}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U $${POSTGRES_USER:-aethercastuser} -d $${POSTGRES_DB:-aethercast_db}"] # Escaped $ for docker-compose
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - aethercast_network
    restart: unless-stopped
    logging:
      driver: "json-file"
      options:
        max-size: "20m"
        max-file: "5"

  api_gateway:
    build:
      context: . # Build context is the project root
      dockerfile: ./aethercast/api_gateway/Dockerfile
    ports:
      - "5001:5001"
    volumes:
      - ./aethercast:/app/aethercast # For live code changes in dev
      # - aethercast_db_data:/app/database # SQLite volume, may be removed later
    env_file:
      - common.env # Shared environment variables
      - ./aethercast/api_gateway/.env # Service-specific vars
    environment:
      # PostgreSQL connection details
      - DATABASE_TYPE=postgres
      - POSTGRES_HOST=postgres_db
      - POSTGRES_PORT=5432
      - POSTGRES_USER=${POSTGRES_USER:-aethercastuser}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD:-aethercastpass}
      - POSTGRES_DB=${POSTGRES_DB:-aethercast_db}
    depends_on:
      postgres_db:
        condition: service_healthy # Wait for Postgres to be healthy
      # - tda # Example, can be added if strict startup order is needed
      # - cpoa (though cpoa is part of api_gateway image)
      # - aims_service # If API Gateway directly called AIMS
      # GCS_BUCKET_NAME is sourced from common.env
      - GCS_BUCKET_NAME=${GCS_BUCKET_NAME}
    networks: # Example: assuming a custom network for all backend services
      - aethercast_network
    logging:
      driver: "json-file"
      options:
        max-size: "20m"
        max-file: "5"

  aims_service:
    build:
      context: ./aethercast/aims_service
      dockerfile: Dockerfile
    container_name: aims_service
    ports:
      - "8008:8000" # Host:Container
    env_file:
      - ./aethercast/aims_service/.env # Users must create this from .env.example
    volumes:
      - ./aethercast/aims_service:/app # For live development of aims_service code
      # Mount the GCP credentials file into the container (read-only)
      # The user must place their gcp-credentials.json in ./aethercast/aims_service/
      # and set GOOGLE_APPLICATION_CREDENTIALS=/app/gcp-credentials.json in aims_service/.env
      - ./aethercast/aims_service/gcp-credentials.json:/app/gcp-credentials.json:ro
    networks:
      - aethercast_network
    restart: unless-stopped
    logging:
      driver: "json-file"
      options:
        max-size: "20m"
        max-file: "5"

  aims_tts_service:
    build:
      context: ./aethercast/aims_tts_service
      dockerfile: Dockerfile
    container_name: aims_tts_service
    ports:
      - "9009:9000" # Host:Container
    env_file:
      - common.env # For GCS_BUCKET_NAME, FLASK_DEBUG_MODE
      - ./aethercast/aims_tts_service/.env # Users must create this from .env.example
    environment:
      # Ensure GOOGLE_APPLICATION_CREDENTIALS is set for GCS and TTS
      GOOGLE_APPLICATION_CREDENTIALS: /app/gcp-credentials.json
      # GCS_BUCKET_NAME can be sourced from common.env or overridden in service .env
      GCS_BUCKET_NAME: ${GCS_BUCKET_NAME}
      AIMS_TTS_GCS_AUDIO_PREFIX: audio/aims_tts/ # Default prefix, can be overridden
      # Flask runtime settings
      AIMS_TTS_HOST: 0.0.0.0
      AIMS_TTS_PORT: 9000
      FLASK_DEBUG: ${FLASK_DEBUG_MODE:-False} # Default to False for TTS if not in common.env
    volumes:
      - ./aethercast/aims_tts_service:/app # For live development
      # Mount GCP credentials, similar to aims_service and iga
      - ./aethercast/aims_tts_service/gcp-credentials.json:/app/gcp-credentials.json:ro
      - aethercast_audio_data:/shared_audio
      # SHARED_AUDIO_DIR_CONTAINER in main.py is now /tmp/aims_tts_temp_audio,
      # so it does not strictly need aethercast_audio_data for its *own* temp files unless
      # that /tmp path is also intended to be on the shared volume (which is unusual).
      # However, VFA *might* still expect the final output path (now a GCS URI) to be relatable
      # to /shared_audio if it tries to access it before CPOA passes the GCS URI.
      # Keeping /shared_audio mounted for now for broader compatibility during transition,
      # though AIMS_TTS itself primarily writes to GCS.
    networks:
      - aethercast_network
    restart: unless-stopped
    logging:
      driver: "json-file"
      options:
        max-size: "20m"
        max-file: "5"

  tda:
    build:
      context: .
      dockerfile: ./aethercast/tda/Dockerfile
    ports:
      - "5000:5000" # Assuming TDA runs on 5000
    volumes:
      - ./aethercast:/app/aethercast
      # - aethercast_db_data:/app/database # SQLite volume, to be removed or conditional
    env_file:
      - common.env
      - ./aethercast/tda/.env
    environment:
      # PostgreSQL connection details for TDA
      - DATABASE_TYPE=postgres
      - POSTGRES_HOST=postgres_db
      - POSTGRES_PORT=5432
      - POSTGRES_USER=${POSTGRES_USER:-aethercastuser}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD:-aethercastpass}
      - POSTGRES_DB=${POSTGRES_DB:-aethercast_db}
    depends_on:
      postgres_db:
        condition: service_healthy
    networks:
      - aethercast_network
    logging:
      driver: "json-file"
      options:
        max-size: "20m"
        max-file: "5"

  sca:
    build:
      context: .
      dockerfile: ./aethercast/sca/Dockerfile
    ports:
      - "5002:5002" # Assuming SCA runs on 5002
    volumes:
      - ./aethercast:/app/aethercast
    env_file:
      - common.env
      - ./aethercast/sca/.env
    depends_on:
      - aims_service
    networks:
      - aethercast_network
    logging:
      driver: "json-file"
      options:
        max-size: "20m"
        max-file: "5"

  pswa:
    build:
      context: .
      dockerfile: ./aethercast/pswa/Dockerfile
    ports:
      - "5004:5004" # Assuming PSWA runs on 5004
    volumes:
      - ./aethercast:/app/aethercast
      # - aethercast_db_data:/app/database # SQLite volume for script caching, to be removed or conditional
    env_file:
      - common.env
      - ./aethercast/pswa/.env
    environment:
      # PostgreSQL connection details for PSWA script cache
      - DATABASE_TYPE=postgres
      - POSTGRES_HOST=postgres_db
      - POSTGRES_PORT=5432
      - POSTGRES_USER=${POSTGRES_USER:-aethercastuser}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD:-aethercastpass}
      - POSTGRES_DB=${POSTGRES_DB:-aethercast_db}
    depends_on:
      - aims_service
      postgres_db:
        condition: service_healthy
    networks:
      - aethercast_network
    logging:
      driver: "json-file"
      options:
        max-size: "20m"
        max-file: "5"

  vfa:
    build:
      context: .
      dockerfile: ./aethercast/vfa/Dockerfile
    ports:
      - "5005:5005" # Assuming VFA runs on 5005
    volumes:
      - ./aethercast:/app/aethercast
      # VFA now primarily consumes paths from AIMS_TTS, which are on /shared_audio
      # It might still write test dummy files to a subdir if VFA_SHARED_AUDIO_DIR is set that way.
      - aethercast_audio_data:/shared_audio
    env_file:
      - common.env
      - ./aethercast/vfa/.env
    depends_on:
      - aims_tts_service
    networks:
      - aethercast_network
    logging:
      driver: "json-file"
      options:
        max-size: "20m"
        max-file: "5"

  asf:
    build:
      context: .
      dockerfile: ./aethercast/asf/Dockerfile
    ports:
      - "5006:5006" # Assuming ASF runs on 5006
    volumes:
      - ./aethercast:/app/aethercast
      - aethercast_audio_data:/shared_audio # ASF might still need this for non-GCS paths or other functionalities
    env_file:
      - common.env
      - ./aethercast/asf/.env
    environment: # Added environment block for ASF
      # INTERNAL_API_GW_BASE_URL will be sourced from asf/.env, which should source it from common.env or define it.
      # Example if sourcing from common.env (ensure common.env has it or it's defined in asf/.env):
      - INTERNAL_API_GW_BASE_URL=${INTERNAL_API_GW_BASE_URL:-http://api_gateway:5001}
    depends_on: # Added depends_on for ASF
      - api_gateway
    networks:
      - aethercast_network
    logging:
      driver: "json-file"
      options:
        max-size: "20m"
        max-file: "5"

  iga:
    build:
      context: ./aethercast/iga # Corrected context
      dockerfile: Dockerfile
    ports:
      - "5007:5007" # Expose port 5007 for IGA
    env_file:
      - common.env # To pick up GCP_PROJECT_ID, GCP_LOCATION, FLASK_DEBUG_MODE
      - ./aethercast/iga/.env # Service-specific vars (user should create this from .env.example)
    environment:
      PYTHONUNBUFFERED: 1
      # Essential for Vertex AI. Path inside the container.
      GOOGLE_APPLICATION_CREDENTIALS: /app/gcp-credentials.json
      # IGA specific Vertex AI settings, can be overridden in .env if needed
      IGA_VERTEXAI_PROJECT_ID: ${GCP_PROJECT_ID} # From common.env
      IGA_VERTEXAI_LOCATION: ${GCP_LOCATION} # From common.env
      IGA_VERTEXAI_IMAGE_MODEL_ID: imagegeneration@006 # Default model
      # IGA_GENERATED_IMAGE_DIR is now less critical as output is GCS URI. Still used for local temp if ever needed.
      IGA_GENERATED_IMAGE_DIR: /shared_audio/iga_images
      GCS_BUCKET_NAME: ${GCS_BUCKET_NAME} # Sourced from common.env
      IGA_GCS_IMAGE_PREFIX: images/iga/ # Default prefix, can be overridden in iga/.env
      IGA_DEFAULT_ASPECT_RATIO: "1:1"
      IGA_ADD_WATERMARK: "True"
      # Flask server settings for IGA
      IGA_HOST: 0.0.0.0
      IGA_PORT: 5007
      FLASK_DEBUG: ${FLASK_DEBUG_MODE:-True} # Use common.env value, default to True
    volumes:
      - ./aethercast/iga:/app # For live development
      # Mount the GCP credentials file into the container (read-only)
      # User must place their gcp-credentials.json in ./aethercast/iga/
      - ./aethercast/iga/gcp-credentials.json:/app/gcp-credentials.json:ro
      # Mount the shared volume for image output
      - aethercast_audio_data:/shared_audio
    networks:
      - aethercast_network
    restart: unless-stopped
    logging:
      driver: "json-file"
      options:
        max-size: "20m"
        max-file: "5"

# Define the custom network
networks:
  aethercast_network:
    driver: bridge

# Note on .env files for services:
# Each service's .env file (e.g., aethercast/api_gateway/.env) will need to be updated/created by the user.
# It should source common.env variables and then define its specific ones.
# Example for aethercast/api_gateway/.env:
#   DATABASE_FILE=${DATABASE_FILE_PATH_CONTAINER}
#   TDA_SERVICE_URL=http://tda:5000/discover_topics
#   # ... other API_GW specific vars
#
# Example for aethercast/pswa/.env:
#   PSWA_DATABASE_PATH=${DATABASE_FILE_PATH_CONTAINER}
#   OPENAI_API_KEY=your_real_key_or_leave_blank_for_no_external_calls_if_test_mode_is_on
#   PSWA_TEST_MODE_ENABLED=True # Enable test mode for integration tests
#
# Example for aethercast/vfa/.env:
#   VFA_SHARED_AUDIO_DIR=${SHARED_AUDIO_DIR_CONTAINER}
#   VFA_TEST_MODE_ENABLED=True # Enable test mode
#
# These service-specific .env files are NOT created by this tool automatically.
# They need to be present or created manually by the user, often by copying from their .env.example
# and then adjusting for the Docker Compose environment (using service names for URLs, container paths).
# The common.env provides the container paths, which are then referenced in the service .env files.
#
# The Dockerfiles copy the *entire* ./aethercast directory into /app/aethercast.
# This means the Python code should use imports like 'from aethercast.module.file import ...'
# and the PYTHONPATH=/app should make this work.
# The CMD ["python", "aethercast/service_dir/main.py"] should also work with this structure.
# The build context for services like api_gateway, tda, etc., is set to '.' (project root)
# to allow Dockerfiles to COPY ./aethercast, while services like aims_service and iga
# have their build context set directly to their own directories.
