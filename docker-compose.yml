version: '3.8'

volumes:
  aethercast_db_data:
  aethercast_audio_data:

services:
  api_gateway:
    build:
      context: . # Build context is the project root
      dockerfile: ./aethercast/api_gateway/Dockerfile
    ports:
      - "5001:5001"
    volumes:
      - ./aethercast:/app/aethercast # For live code changes in dev
      - aethercast_db_data:/app/database # Named volume for DB
    env_file:
      - common.env # Shared environment variables
      - ./aethercast/api_gateway/.env # Service-specific vars
    # depends_on: # Example, can be added if strict startup order is needed
      # - tda
      # - cpoa (though cpoa is part of api_gateway image)
      # - aims_service # If API Gateway directly called AIMS
    networks: # Example: assuming a custom network for all backend services
      - aethercast_network

  aims_service:
    build:
      context: ./aethercast/aims_service
      dockerfile: Dockerfile
    container_name: aims_service
    ports:
      - "8008:8000" # Host:Container
    env_file:
      - ./aethercast/aims_service/.env # Users must create this from .env.example
    volumes:
      - ./aethercast/aims_service:/app # For live development of aims_service code
      # Mount the GCP credentials file into the container (read-only)
      # The user must place their gcp-credentials.json in ./aethercast/aims_service/
      # and set GOOGLE_APPLICATION_CREDENTIALS=/app/gcp-credentials.json in aims_service/.env
      - ./aethercast/aims_service/gcp-credentials.json:/app/gcp-credentials.json:ro
    networks:
      - aethercast_network
    restart: unless-stopped

  aims_tts_service:
    build:
      context: ./aethercast/aims_tts_service
      dockerfile: Dockerfile
    container_name: aims_tts_service
    ports:
      - "9009:9000" # Host:Container
    env_file:
      - ./aethercast/aims_tts_service/.env # Users must create this from .env.example
    volumes:
      - ./aethercast/aims_tts_service:/app # For live development
      - aethercast_audio_data:/shared_audio # Shared volume for TTS output
    networks:
      - aethercast_network
    restart: unless-stopped

  tda:
    build:
      context: .
      dockerfile: ./aethercast/tda/Dockerfile
    ports:
      - "5000:5000" # Assuming TDA runs on 5000
    volumes:
      - ./aethercast:/app/aethercast
      - aethercast_db_data:/app/database
    env_file:
      - common.env
      - ./aethercast/tda/.env
    networks:
      - aethercast_network

  sca:
    build:
      context: .
      dockerfile: ./aethercast/sca/Dockerfile
    ports:
      - "5002:5002" # Assuming SCA runs on 5002
    volumes:
      - ./aethercast:/app/aethercast
    env_file:
      - common.env
      - ./aethercast/sca/.env
    depends_on:
      - aims_service
    networks:
      - aethercast_network

  pswa:
    build:
      context: .
      dockerfile: ./aethercast/pswa/Dockerfile
    ports:
      - "5004:5004" # Assuming PSWA runs on 5004
    volumes:
      - ./aethercast:/app/aethercast
      - aethercast_db_data:/app/database # For script caching
    env_file:
      - common.env
      - ./aethercast/pswa/.env
    depends_on:
      - aims_service
    networks:
      - aethercast_network

  vfa:
    build:
      context: .
      dockerfile: ./aethercast/vfa/Dockerfile
    ports:
      - "5005:5005" # Assuming VFA runs on 5005
    volumes:
      - ./aethercast:/app/aethercast
      # VFA now primarily consumes paths from AIMS_TTS, which are on /shared_audio
      # It might still write test dummy files to a subdir if VFA_SHARED_AUDIO_DIR is set that way.
      - aethercast_audio_data:/shared_audio
    env_file:
      - common.env
      - ./aethercast/vfa/.env
    depends_on:
      - aims_tts_service
    networks:
      - aethercast_network

  asf:
    build:
      context: .
      dockerfile: ./aethercast/asf/Dockerfile
    ports:
      - "5006:5006" # Assuming ASF runs on 5006
    volumes:
      - ./aethercast:/app/aethercast
      - aethercast_audio_data:/shared_audio # ASF needs to read audio files from the shared volume
    env_file:
      - common.env
      - ./aethercast/asf/.env
    networks:
      - aethercast_network

  iga:
    build:
      context: ./aethercast/iga # Corrected context
      dockerfile: Dockerfile
    ports:
      - "5007:5007" # Expose port 5007 for IGA
    env_file:
      - common.env # To pick up GCP_PROJECT_ID, GCP_LOCATION, FLASK_DEBUG_MODE
      - ./aethercast/iga/.env # Service-specific vars (user should create this from .env.example)
    environment:
      PYTHONUNBUFFERED: 1
      # Essential for Vertex AI. Path inside the container.
      GOOGLE_APPLICATION_CREDENTIALS: /app/gcp-credentials.json
      # IGA specific Vertex AI settings, can be overridden in .env if needed
      IGA_VERTEXAI_PROJECT_ID: ${GCP_PROJECT_ID} # From common.env
      IGA_VERTEXAI_LOCATION: ${GCP_LOCATION} # From common.env
      IGA_VERTEXAI_IMAGE_MODEL_ID: imagegeneration@006 # Default model
      IGA_GENERATED_IMAGE_DIR: /shared_audio/iga_images # Path on shared volume
      IGA_DEFAULT_ASPECT_RATIO: "1:1"
      IGA_ADD_WATERMARK: "True"
      # Flask server settings for IGA
      IGA_HOST: 0.0.0.0
      IGA_PORT: 5007
      FLASK_DEBUG: ${FLASK_DEBUG_MODE:-True} # Use common.env value, default to True
    volumes:
      - ./aethercast/iga:/app # For live development
      # Mount the GCP credentials file into the container (read-only)
      # User must place their gcp-credentials.json in ./aethercast/iga/
      - ./aethercast/iga/gcp-credentials.json:/app/gcp-credentials.json:ro
      # Mount the shared volume for image output
      - aethercast_audio_data:/shared_audio
    networks:
      - aethercast_network
    restart: unless-stopped

# Define the custom network
networks:
  aethercast_network:
    driver: bridge

# Note on .env files for services:
# Each service's .env file (e.g., aethercast/api_gateway/.env) will need to be updated/created by the user.
# It should source common.env variables and then define its specific ones.
# Example for aethercast/api_gateway/.env:
#   DATABASE_FILE=${DATABASE_FILE_PATH_CONTAINER}
#   TDA_SERVICE_URL=http://tda:5000/discover_topics
#   # ... other API_GW specific vars
#
# Example for aethercast/pswa/.env:
#   PSWA_DATABASE_PATH=${DATABASE_FILE_PATH_CONTAINER}
#   OPENAI_API_KEY=your_real_key_or_leave_blank_for_no_external_calls_if_test_mode_is_on
#   PSWA_TEST_MODE_ENABLED=True # Enable test mode for integration tests
#
# Example for aethercast/vfa/.env:
#   VFA_SHARED_AUDIO_DIR=${SHARED_AUDIO_DIR_CONTAINER}
#   VFA_TEST_MODE_ENABLED=True # Enable test mode
#
# These service-specific .env files are NOT created by this tool automatically.
# They need to be present or created manually by the user, often by copying from their .env.example
# and then adjusting for the Docker Compose environment (using service names for URLs, container paths).
# The common.env provides the container paths, which are then referenced in the service .env files.
#
# The Dockerfiles copy the *entire* ./aethercast directory into /app/aethercast.
# This means the Python code should use imports like 'from aethercast.module.file import ...'
# and the PYTHONPATH=/app should make this work.
# The CMD ["python", "aethercast/service_dir/main.py"] should also work with this structure.
# The build context for services like api_gateway, tda, etc., is set to '.' (project root)
# to allow Dockerfiles to COPY ./aethercast, while services like aims_service and iga
# have their build context set directly to their own directories.
