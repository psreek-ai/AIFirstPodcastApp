# --- AIMS Service Configuration ---
# URL for the AIMS (AI Model Service) - derived from common.env
AIMS_SERVICE_URL=${AIMS_SERVICE_BASE_URL_CONTAINER}/v1/generate
# Timeout in seconds for requests to the AIMS service
AIMS_REQUEST_TIMEOUT_SECONDS=180
# Polling interval in seconds when waiting for AIMS async task results
AIMS_POLLING_INTERVAL_SECONDS=5
# Overall timeout in seconds for polling AIMS task results
AIMS_POLLING_TIMEOUT_SECONDS=300

# --- LLM Parameters (These are now requests to AIMS) ---
# PSWA_LLM_MODEL: The Model ID to request from AIMS.
# Examples: gpt-3.5-turbo-0125, gpt-4-turbo-preview, or custom model IDs AIMS might support.
PSWA_LLM_MODEL=gpt-3.5-turbo-0125

# PSWA_LLM_TEMPERATURE: Temperature for the LLM response (0.0 to 2.0).
PSWA_LLM_TEMPERATURE=0.7

# PSWA_LLM_MAX_TOKENS: Maximum tokens to generate in the LLM response.
PSWA_LLM_MAX_TOKENS=1500

# PSWA_LLM_JSON_MODE: Set to 'true' to request JSON output from AIMS (if the model supports it).
# If 'true', ensure system/user prompts guide the LLM for JSON output.
# If 'false' or if the model doesn't support JSON mode flag, PSWA will rely on tag-based parsing from text.
PSWA_LLM_JSON_MODE=true

# --- Prompt Engineering ---
# PSWA_DEFAULT_PROMPT_USER_TEMPLATE: Template for the user message to the LLM.
# Use {topic}, {content}, and {narrative_guidance} as placeholders.
PSWA_DEFAULT_PROMPT_USER_TEMPLATE='Generate a podcast script for topic ''{topic}'' using the following content:
---
{content}
---
{narrative_guidance}
Remember, your entire response must be a single JSON object conforming to the schema provided in the system message.'

# Persona and Prompt Configuration
PSWA_DEFAULT_PERSONA=InformativeHost

# PSWA_PERSONA_PROMPTS_JSON: JSON string defining system message additions for different personas.
# Ensure valid JSON with escaped quotes where necessary. python-dotenv supports multi-line values enclosed in single quotes.
PSWA_PERSONA_PROMPTS_JSON='{
    "InformativeHost": "You are ''The Informative Host'', an AI specializing in clear and engaging explanations of complex topics. Your goal is to educate the listener thoroughly and objectively. Structure the script with a clear introduction, logically sequenced segments each building on the last, and a concise summary in the outro. Prioritize clarity and accuracy based on the provided content.",
    "ConversationalExplorer": "You are ''Alex, The Conversational Explorer'', an AI podcast host who loves to learn and share interesting things in a friendly, approachable way. Speak as if you''re chatting with a curious friend. Feel free to use phrases like ''Isn''t that interesting?'' or ''Let''s see what this means...''. Ensure the script flows like a natural conversation, with engaging questions and smooth transitions between ideas.",
    "HumorousCommentator": "You are ''Sparky, The Humorous Commentator'', an AI with a knack for finding the funny side of any topic. Your goal is to entertain while informing. Inject humor, wit, and clever observations related to the content. Use wordplay or light sarcasm if appropriate. Keep the tone light and engaging, even for serious topics (but don''t be disrespectful). The script should be genuinely amusing."
}'

# PSWA_BASE_SYSTEM_MESSAGE_JSON_SCHEMA_INSTRUCTION: Base instruction appended to persona message, focusing on JSON schema.
PSWA_BASE_SYSTEM_MESSAGE_JSON_SCHEMA_INSTRUCTION='Your output MUST be a single, valid JSON object. Do not include any text outside of this JSON object, not even markdown tags like ```json. The JSON object should conform to the following schema: {"title": "string (The main title of the podcast)", "intro": "string (The introductory part of the podcast script, 2-3 sentences)", "segments": [{"segment_title": "string (Title of this segment, e.g., ''Segment 1: The Core Idea'')", "content": "string (Content of this segment, several sentences or paragraphs)"}], "outro": "string (The concluding part of the podcast script, 2-3 sentences)"}. Ensure all script content is engaging and based on the provided topic and source content. There should be at least an intro, one segment, and an outro. If the provided source content is insufficient to generate a meaningful script with at least one segment, return a JSON object with an error field: {"error": "Insufficient content", "message": "The provided content was not sufficient to generate a full podcast script for the topic: [topic_name_here]."}'

# PSWA_NARRATIVE_GUIDANCE_USER_PROMPT_ADDITION: General narrative guidance added to the user prompt.
PSWA_NARRATIVE_GUIDANCE_USER_PROMPT_ADDITION='When writing the segments, ensure you start with a compelling hook in the intro, develop key points logically with smooth transitions, and end with a satisfying conclusion in the outro. Vary sentence structure for engagement. Ensure the overall script is coherent and engaging for the listener.'


# --- Script Caching Database Configuration ---
# Set DATABASE_TYPE to 'postgres' or 'sqlite'. Default is 'sqlite'.
DATABASE_TYPE=sqlite

# For SQLite (if DATABASE_TYPE=sqlite and PSWA_SCRIPT_CACHE_ENABLED=true)
# Path to the shared SQLite database file for script caching.
# This should reference the var from common.env: e.g., ${SHARED_DATABASE_PATH}
SHARED_DATABASE_PATH=${SHARED_DATABASE_PATH}

# For PostgreSQL (if DATABASE_TYPE=postgres and (PSWA_SCRIPT_CACHE_ENABLED=true OR for Idempotency))
# These should ideally be sourced from common.env or use defaults set in docker-compose.
POSTGRES_HOST=postgres_db
POSTGRES_PORT=5432
POSTGRES_USER=${POSTGRES_USER}
POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
POSTGRES_DB=${POSTGRES_DB}

# PSWA_SCRIPT_CACHE_ENABLED: Set to 'true' to enable script caching, 'false' to disable.
PSWA_SCRIPT_CACHE_ENABLED=true

# PSWA_SCRIPT_CACHE_MAX_AGE_HOURS: Maximum age of a cached script in hours before it's considered stale.
# 720 hours = 30 days
PSWA_SCRIPT_CACHE_MAX_AGE_HOURS=720

# --- Idempotency Configuration (uses PostgreSQL) ---
# IDEMPOTENCY_STATUS_PROCESSING: Value for 'processing' status in idempotency_keys table.
IDEMPOTENCY_STATUS_PROCESSING=processing
# IDEMPOTENCY_STATUS_COMPLETED: Value for 'completed' status in idempotency_keys table.
IDEMPOTENCY_STATUS_COMPLETED=completed
# IDEMPOTENCY_STATUS_FAILED: Value for 'failed' status in idempotency_keys table.
IDEMPOTENCY_STATUS_FAILED=failed
# IDEMPOTENCY_LOCK_TIMEOUT_SECONDS: Duration in seconds to consider an idempotency key lock as expired.
IDEMPOTENCY_LOCK_TIMEOUT_SECONDS=3600


# --- Test Mode for Integration Testing ---
# PSWA_TEST_MODE_ENABLED: Set to 'true' to bypass LLM calls (including AIMS) and return a dummy script.
# Recommended for integration tests to avoid external dependencies and costs.
PSWA_TEST_MODE_ENABLED=true

# --- Flask App Parameters ---
# PSWA_HOST=0.0.0.0
# PSWA_PORT=5004
# PSWA_DEBUG_MODE=True # For direct Flask run, Docker Compose typically uses FLASK_DEBUG from common.env
# FLASK_DEBUG=${FLASK_DEBUG_MODE} # Standard Flask debug mode

# --- Celery Configuration (for PSWA to run its own tasks) ---
# URL for the Celery message broker (e.g., Redis)
CELERY_BROKER_URL=redis://redis:6379/0
# URL for the Celery result backend (e.g., Redis)
CELERY_RESULT_BACKEND=redis://redis:6379/0
