# Dynamic UI Schema for Backend-Driven Presentation

## 1. Introduction

This document outlines the requirements and initial thoughts towards a schema that the backend system (primarily the Central Podcast Orchestrator Agent - CPOA, potentially in conjunction with a conceptual Dynamic UI Agent - DUIA) will use to define and drive the user interface of the Aethercast application.

The core vision of Aethercast, as detailed in `docs/vision/01_AI_First_Agentic_System_Requirements.md` and `docs/vision/03_Podcast_App_Manifesto.md`, is an AI-first system where the entire user experience, including content, layout, and visual style, is dynamically generated in real-time. This document aims to define what information the backend needs to provide to the frontend to achieve this dynamic UI.

While the long-term vision includes AI models directly generating layout (HTML/CSS) and styling, the initial implementation might involve the backend sending structured data or commands that instruct the frontend on how to assemble and style pre-defined components or templates. This schema should be flexible enough to accommodate both current practicalities and future ambitions.

## 2. Requirements for Backend-Driven Dynamic UI

The following requirements have been extracted from the project's vision and architecture documents.

### 2.1. Content Definition
*(Primarily generated by specialized agents like SCA, IGA, VFA, and orchestrated by CPOA; this data is then an input to the UI generation/update process.)*

*   **R.CD.1:** The backend must provide all textual content to be displayed.
    *   *Source:* `docs/vision/01_AI_First_Agentic_System_Requirements.md#1.4`
*   **R.CD.2:** The backend must provide image URLs (e.g., for snippets, cover art). These URLs are short-lived signed GCS URLs.
    *   *Source:* `docs/vision/01_AI_First_Agentic_System_Requirements.md#1.4`, `docs/vision/03_Podcast_App_Manifesto.md#User Journey`
*   **R.CD.3:** The backend must provide identifiers or URLs for audio streams.
    *   *Source:* `docs/vision/03_Podcast_App_Manifesto.md#User Journey`

### 2.2. Layout Generation
*   **R.LG.1:** The backend must define the overall structure and layout of UI pages and components.
    *   *Source:* `docs/vision/01_AI_First_Agentic_System_Requirements.md#1.4, #3.2`
*   **R.LG.2:** The backend must be capable of specifying responsive layouts that adapt to various screen sizes and orientations.
    *   *Source:* `docs/vision/01_AI_First_Agentic_System_Requirements.md#3.2`
*   **R.LG.3:** The backend must support the generation or selection of different layout patterns (e.g., multi-column, single-column, card-based, grid-based).
    *   *Source:* `docs/vision/01_AI_First_Agentic_System_Requirements.md#3.2`
*   **R.LG.4:** The `DynamicUIAgent` (or CPOA fulfilling this role) is responsible for defining the visual presentation of specific UI elements like snippets and playback controls.
    *   *Source:* `docs/vision/03_Podcast_App_Manifesto.md#Principle 2`, `docs/architecture/AI_Agents_Overview.md#3.6`

### 2.3. Visual Style Generation
*   **R.VS.1:** The backend must define parameters for visual styling, which could include color palettes, typography choices, spacing rules, and overall themes.
    *   *Source:* `docs/vision/01_AI_First_Agentic_System_Requirements.md#1.4, #3.3`
*   **R.VS.2:** The `DynamicUIAgent` (or CPOA fulfilling this role) manages the thematic presentation of the application.
    *   *Source:* `docs/vision/03_Podcast_App_Manifesto.md#Principle 6`

### 2.4. Dynamic Updates & Regeneration
*   **R.DU.1:** The backend must be able to specify which parts of the UI need to be regenerated or updated in response to user interactions or system events. This implies a granular update capability.
    *   *Source:* `docs/vision/01_AI_First_Agentic_System_Requirements.md#1.5, #4.3`
*   **R.DU.2:** The backend (CPOA) sends UI update instructions/data to the frontend, potentially via API responses or real-time messaging (WebSockets).
    *   *Source:* `docs/architecture/System_Architecture.md#CPOA`, `docs/architecture/AI_Agents_Overview.md#3.6`

### 2.5. Interaction Handling (Backend Perspective)
*   **R.IH.1:** The backend system (CPOA) receives interaction events from the frontend. UI regeneration is a common response to these events. The schema must support conveying UI changes triggered by these interactions.
    *   *Source:* `docs/vision/01_AI_First_Agentic_System_Requirements.md#1.5`

### 2.6. Contextual Adaptation
*   **R.CA.1:** The UI structure, content, and style defined by the backend should be adaptable based on user context, interaction history, and inferred goals. The schema should be flexible enough to represent these adaptations.
    *   *Source:* `docs/vision/01_AI_First_Agentic_System_Requirements.md#1.6`

### 2.7. Accessibility & Semantics
*   **R.AS.1:** Any layout structures or styling parameters defined by the backend must facilitate the frontend's ability to render semantically meaningful and accessible (e.g., WCAG compliant) UI.
    *   *Source:* `docs/vision/01_AI_First_Agentic_System_Requirements.md#3.2, #3.3, #8.5`

## 3. UI Definition JSON Schema

This section details the proposed JSON schema for the backend to define and drive the frontend UI.

### 3.1. Root Element

The root of a UI definition sent from the backend to the frontend.

```json
{
    "view_id": "unique_view_identifier",
    "schema_version": "1.0",
    "context_data": {
        "user_name": "Jane Doe",
        "is_subscribed": false,
        "snippets_array": [ /* ... array of snippet data objects ... */ ]
        // ... other global data for this view
    },
    "root_component": {
        // Component Object (see below)
    }
}
```

-   `view_id` (string, required): A unique identifier for the current view or page (e.g., "landing_page", "podcast_detail_view", "search_results_view"). Useful for client-side caching or view-specific logic.
-   `schema_version` (string, required): Version of this UI schema (e.g., "1.0").
-   `context_data` (object, optional): A global data object available for data binding throughout this view. Component-specific data can override or augment this.
-   `root_component` (object, required): The top-level component object that defines the entire UI for this view.

### 3.2. Component Model (Core Structure)

Each UI element is represented as a component object.

```json
{
    "type": "component_type_name",
    "id": "optional_unique_component_id",
    "props": {
        // Component-specific properties (see specific component schemas)
        // Includes content, layout, style, events, data_source, etc.
    },
    "children": [
        // Optional array of nested component objects
    ]
}
```

-   `type` (string, required): Specifies the kind of component (e.g., "container", "text", "image", "button").
-   `id` (string, optional): A unique identifier for this specific component instance. Useful for targeting UI updates, event handling, or testing.
-   `props` (object, required): An object containing all properties specific to this component type, including its content, layout, styling, interactivity hooks, and data bindings.
-   `children` (array, optional): An array of nested component objects, allowing for hierarchical UI structures. Typically used by `container` or `card` components.

### 3.3. Common Property Groups within `props`

#### 3.3.1. Layout Properties (`props.layout`)

Defines how a component and its children (if any) are arranged. These properties generally map to CSS Flexbox and box model properties.

```json
"props": {
    "layout": {
        "display": "flex" | "block" | "inline-block" | "none", // Default varies by component type
        "direction": "row" | "column", // For flex containers
        "align_items": "flex-start" | "center" | "flex-end" | "stretch" | "baseline",
        "justify_content": "flex-start" | "center" | "flex-end" | "space-between" | "space-around" | "space-evenly",
        "wrap": "nowrap" | "wrap" | "wrap-reverse", // For flex containers
        "gap": "string (e.g., '10px', '0.5rem')",
        "padding": "string (e.g., '10px', '10px 20px') or object {'top':'10px', ...}",
        "margin": "string or object",
        "width": "string (e.g., '100%', 'auto', '300px')",
        "height": "string",
        "min_width": "string", "min_height": "string",
        "max_width": "string", "max_height": "string",
        "flex_grow": "number",
        "flex_shrink": "number",
        "flex_basis": "string (e.g., 'auto', '200px', '50%')",
        "position": "static" | "relative" | "absolute" | "fixed" | "sticky",
        "top": "string", "right": "string", "bottom": "string", "left": "string", // For positioned elements
        "overflow": "visible" | "hidden" | "scroll" | "auto",
        "zIndex": "number" // For stacking order
    }
    // ... other props ...
}
```

#### 3.3.2. Styling Properties (`props.style`)

Defines the visual appearance of a component. These generally map to CSS properties.

```json
"props": {
    "style": {
        "backgroundColor": "string (hex, rgba, CSS color name, 'transparent')",
        "textColor": "string",
        "fontFamily": "string (e.g., 'Arial, sans-serif')",
        "fontSize": "string (e.g., '16px', '1.2em', 'var(--font-size-medium)')",
        "fontWeight": "'normal' | 'bold' | '100' | ... | '900'",
        "fontStyle": "'normal' | 'italic'",
        "textAlign": "'left' | 'center' | 'right' | 'justify'",
        "textDecoration": "'none' | 'underline' | 'line-through'",
        "lineHeight": "string or number (e.g., '1.5', '24px')",
        "borderRadius": "string (e.g., '5px', '50%')",
        "border": "string (e.g., '1px solid #ccc')",
        "boxShadow": "string (e.g., '2px 2px 5px rgba(0,0,0,0.1)')",
        "opacity": "number (0 to 1)",
        "backgroundImageUrl": "string (URL)",
        "objectFit": "'cover' | 'contain' | 'fill' | 'scale-down' | 'none'", // For images/media
        "cursor": "string (e.g., 'pointer', 'default', 'not-allowed')",
        "customCssClass": "string or array of strings" // For applying pre-defined CSS classes
    }
    // ... other props ...
}
```

#### 3.3.3. Interactivity (`props.events`)

Defines actions to be taken in response to user events.

```json
"props": {
    "events": {
        "onClick": { // Or an array of action objects
            "action_type": "API_CALL" | "NAVIGATE" | "UPDATE_CONTEXT_DATA" | "SHOW_MODAL" | "CUSTOM_EVENT",
            // Properties specific to action_type:
            // For "API_CALL":
            "endpoint": "/api/v1/...",
            "method": "POST", // "GET", "PUT", "DELETE"
            "payload_template": {"key": "{self.props.data.id}", "value": "{view.context_data.some_input}"},
            "response_actions": [ /* array of further action objects for success/failure */ ],
            // For "NAVIGATE":
            "target_path": "/details/{self.props.data.id}",
            // For "UPDATE_CONTEXT_DATA":
            "updates": {"view.context_data.counter": "{view.context_data.counter + 1}"}, // Simple expressions might need client-side eval
            "trigger_rerender": true, // default true
            // For "SHOW_MODAL":
            "modal_id": "subscribeModal",
            "modal_context": {"initial_email": "{view.context_data.user_email}"},
            // For "CUSTOM_EVENT":
            "event_name": "userEngagedWithFeatureX",
            "event_data": {"feature_details": "{self.props.details}"}
        }
        // Other events: onHover, onFocus, onBlur, onInput (for input fields)
    }
    // ... other props ...
}
```
*Note: Complex expression evaluation within `payload_template` or `updates` would require a safe client-side evaluation mechanism.*

#### 3.3.4. Data Binding (`props.data_source` and templating)

A convention for referencing data within component properties.
-   `props.data_source`: String path pointing to data in the context (e.g., `"{view.context_data.user_name}"` for a text component's content, or `"{view.context_data.snippets_array}"` for a `list_view`).
-   Templating Syntax: Simple curly braces `{path.to.data}` are used within string values of props.
    -   `{self.props.*}`: Accesses props passed directly to the current component instance.
    -   `{item.*}`: Within a `list_view`'s `item_template`, refers to properties of the current item from the iterated `data_source`.
    -   `{view.context_data.*}`: Accesses data from the global `context_data` at the root of the view schema.
    -   `{view.state.*}`: (Future) Could refer to client-side managed state specific to the current view.

#### 3.3.5. Conditional Rendering (`props.visibility_condition`)
-   `props.visibility_condition`: Optional string. A simple expression string evaluated on the client-side. If it evaluates to `false`, the component (and its children) are not rendered.
    -   Example: `"{view.context_data.user_is_logged_in === true}"`
    -   Example: `"{self.props.data.status === 'active'}"`
    -   *Note: The complexity of allowed expressions needs careful definition and a safe client-side evaluation mechanism.*

### 3.4. Specific Component Schemas

#### 3.4.1. `container`
-   **`type`: `"container"`**
-   **Description:** A generic component for grouping other components and applying layout and styles. Can be nested.
-   **`props`:**
    -   `layout`: (object) Layout properties as defined in 3.3.1.
    -   `style`: (object) Styling properties as defined in 3.3.2.
    -   `semantic_as`: (string, optional, default "div") HTML tag to render as (e.g., "div", "section", "article", "nav", "aside", "header", "footer").
    -   `events`: (object, optional) Event handlers, e.g., `onClick`.

#### 3.4.2. `text`
-   **`type`: `"text"`**
-   **Description:** Displays textual content.
-   **`props`:**
    -   `content`: (string, required) The text to display. Can use data binding (e.g., `"{view.context_data.page_title}"`).
    -   `semantic_as`: (string, optional, default "p") HTML tag (e.g., "p", "h1", "h2", "h3", "span", "label").
    -   `style`: (object) Styling properties.
    -   `layout`: (object, optional) Layout properties.

#### 3.4.3. `image`
-   **`type`: `"image"`**
-   **Description:** Displays an image.
-   **`props`:**
    -   `src`: (string, required) Image URL. Can use data binding (e.g., `"{item.image_gcs_signed_url}"`).
    -   `alt_text`: (string, optional) Alternative text for accessibility. Can use data binding.
    -   `aspect_ratio`: (string, optional) Desired aspect ratio (e.g., "16/9", "1/1", "4/3"). Frontend can use this to maintain ratio.
    -   `layout`: (object) Layout properties (e.g., `width`, `height`).
    -   `style`: (object) Styling properties (e.g., `objectFit: "cover"`).

#### 3.4.4. `button`
-   **`type`: `"button"`**
-   **Description:** A clickable button.
-   **`props`:**
    -   `label`: (string, required) Button text. Can use data binding.
    -   `icon_left`, `icon_right`: (string, optional) Icon identifier (e.g., Material Icon name).
    -   `variant`: (string, optional, default "primary") Predefined style variant (e.g., "primary", "secondary", "outline", "link").
    -   `disabled_condition`: (string, optional) Condition for disabling the button.
    -   `events`: (object, required for action) Contains `onClick` definition as per 3.3.3.
    -   `layout`: (object, optional) Layout properties.
    -   `style`: (object, optional) Styling properties.

#### 3.4.5. `audio_player` (Simplified)
-   **`type`: `"audio_player"`**
-   **Description:** Displays controls for audio playback.
-   **`props`:**
    -   `src`: (string, required) Audio source URL (GCS signed URL or reference to an ASF stream_id). Data-bindable.
    -   `title`: (string, optional) Track title. Data-bindable.
    -   `artist`: (string, optional) Artist name. Data-bindable.
    *   `album_art_src`: (string, optional) URL for album art. Data-bindable.
    *   `layout`: (object, optional) Layout properties.
    *   `style`: (object, optional) Styling properties.
    *   *Note: Actual playback control (play, pause, volume) would typically be handled by the frontend player component itself, but the backend could send commands via `UPDATE_CONTEXT_DATA` actions if needed for more complex scenarios.*

#### 3.4.6. `list_view`
-   **`type`: `"list_view"`**
-   **Description:** Renders a list of items based on a data source and an item template.
-   **`props`:**
    -   `data_source`: (string, required) Path to an array in the context (e.g., `"{view.context_data.searchResults}"`).
    -   `item_template`: (object, required) A single component object definition used to render each item in the `data_source`. Inside this template, data for the current item can be accessed using the `"{item.field_name}"` binding syntax.
    -   `layout`: (object, optional) Layout properties for the list container itself (e.g., direction of items if flex, gap between items).
    -   `style`: (object, optional) Styling properties for the list container.
    -   `empty_state_component`: (object, optional) A component definition to display if `data_source` is null or an empty array.
    -   `list_id`: (string, optional) An ID for the list, useful if multiple lists need distinct handling on the client.

#### 3.4.7. `card`
-   **`type`: `"card"`**
-   **Description:** A container typically used to group related content with card-like styling (e.g., border, shadow, padding). Often used as the `item_template` in a `list_view`.
-   **`props`:**
    -   `layout`: (object) Layout properties.
    -   `style`: (object) Styling properties.
    -   `events`: (object, optional) Event handlers, e.g., `onClick` for the entire card.
    -   `data_source`: (string, optional) Path to an object in context if the card represents a single complex item.

#### 3.4.8. `spacer`
-   **`type`: `"spacer"`**
-   **Description:** Used to create empty space in layouts.
-   **`props`:**
    -   `layout`: (object, required) Must contain `height` or `width` (e.g., `{"height": "20px"}`).

#### 3.4.9. `input_field`
-   **`type`: `"input_field"`**
-   **Description:** A generic input field.
-   **`props`:**
    -   `label`: (string, optional) Label text for the input.
    -   `placeholder`: (string, optional) Placeholder text.
    -   `input_type`: (string, optional, default "text") e.g., "text", "email", "password", "number", "search".
    -   `bind_to_context`: (string, required) Path in `view.context_data` where the input's value is stored and updated (two-way binding). E.g., `"view.context_data.search_query"`.
    -   `value`: (string, optional) Initial value, typically data-bound from `bind_to_context`.
    -   `style`: (object, optional) Styling properties.
    -   `layout`: (object, optional) Layout properties.
    -   `events`: (object, optional) Event handlers like `onInput`, `onChange`, `onEnterPress`.
        -   `onEnterPress` could have an `action_type` like "SUBMIT_SEARCH" or trigger a generic `API_CALL`.

### 3.5. JSON Schema Examples

#### Example 1: Simple Text Component

```json
{
    "type": "text",
    "props": {
        "content": "Welcome, {view.context_data.user_name}!",
        "semantic_as": "h1",
        "style": {
            "textColor": "#333333",
            "fontSize": "24px"
        }
    }
}
```

#### Example 2: Container with Children

```json
{
    "type": "container",
    "props": {
        "layout": {
            "direction": "column",
            "gap": "15px",
            "padding": "20px"
        },
        "style": {
            "backgroundColor": "#f0f0f0"
        }
    },
    "children": [
        {
            "type": "text",
            "props": {"content": "Section Title", "semantic_as": "h2"}
        },
        {
            "type": "text",
            "props": {"content": "This is a paragraph within the container."}
        }
    ]
}
```

#### Example 3: `list_view` of `card` Components (Illustrating Nesting & Data Binding)

```json
// Assuming view.context_data.articles = [
//   { "id": "1", "title": "Article 1", "summary": "Summary of A1", "image_url": "url1.jpg" },
//   { "id": "2", "title": "Article 2", "summary": "Summary of A2", "image_url": "url2.jpg" }
// ]
{
    "type": "list_view",
    "props": {
        "data_source": "{view.context_data.articles}",
        "layout": {
            "direction": "column",
            "gap": "10px"
        },
        "item_template": {
            "type": "card",
            "id_template": "article_card_{item.id}", // Dynamic ID for each card
            "props": {
                "layout": {"direction": "row", "gap": "10px", "padding": "10px"},
                "style": {"border": "1px solid #ddd", "borderRadius": "5px"},
                "events": {
                    "onClick": {
                        "action_type": "NAVIGATE",
                        "target_path": "/article/{item.id}"
                    }
                }
            },
            "children": [
                {
                    "type": "image",
                    "props": {
                        "src": "{item.image_url}",
                        "alt_text": "Image for {item.title}",
                        "layout": {"width": "100px", "height": "100px"},
                        "style": {"objectFit": "cover", "borderRadius": "3px"}
                    }
                },
                {
                    "type": "container",
                    "props": {"layout": {"direction": "column", "flex_grow": 1}},
                    "children": [
                        {
                            "type": "text",
                            "props": {"content": "{item.title}", "semantic_as": "h3", "style": {"fontSize": "18px"}}
                        },
                        {
                            "type": "text",
                            "props": {"content": "{item.summary}", "style": {"fontSize": "14px"}}
                        }
                    ]
                }
            ]
        }
    }
}
```

#### Example 4: Button with `onClick` API Call

```json
{
    "type": "button",
    "props": {
        "label": "Submit Feedback",
        "variant": "primary",
        "events": {
            "onClick": {
                "action_type": "API_CALL",
                "endpoint": "/api/v1/feedback",
                "method": "POST",
                "payload_template": {
                    "feedback_text": "{view.context_data.feedback_input_value}",
                    "user_id": "{view.context_data.user_id}"
                },
                "response_actions": [
                    {
                        "action_type": "UPDATE_CONTEXT_DATA",
                        "updates": {"view.context_data.feedback_message": "Thanks for your feedback!"}
                    }
                ]
            }
        }
    }
}
```

### 3.6. Schema Versioning

To allow for future evolution of this UI schema, all root UI definition objects should include a `schema_version` property.
```json
{
    "view_id": "...",
    "schema_version": "1.0",
    // ... rest of the schema
}
```
This allows the frontend to adapt to different schema versions or provide warnings/errors if it receives an unsupported version.

### 3.7. Open Questions / Future Considerations

-   **Complex Forms & Inputs:** Detailed schema for various input types (selects, checkboxes, radio groups, text areas) and their validation state driven by the backend.
-   **Advanced Styling:** How to handle pseudo-classes, pseudo-elements, media queries directly within the schema if not relying solely on `customCssClass`.
-   **Client-Side Routing Integration:** How `NAVIGATE` actions interact with the frontend router if it has its own state/logic.
-   **Accessibility (ARIA attributes):** How to specify ARIA roles, states, and properties for components beyond `semantic_as`.
-   **Animation/Transition Control:** Defining parameters for animations or transitions between UI states.
-   **Client-Side State Management:** How much temporary UI state (e.g., toggle states not persisted) should be manageable via backend instructions vs. pure client-side logic.
-   **Error Boundaries:** Defining components that can catch and display errors within a part of the UI tree.
-   **Performance of Large Schemas:** For very complex views, the size of the JSON schema and the cost of parsing/rendering it on the client need to be considered.

---
This document will evolve as the specific data structures for backend-driven UI are designed and implemented.

## 4. Backend UI Schema Generation Logic

This section outlines how the backend, conceptualized primarily via the `DynamicUIAgent` (DUIA) interacting with CPOA, would generate the UI Definition JSON described above.

### 4.1. Inputs to UI Generation

The DUIA (or equivalent logic within CPOA) requires several key inputs to generate a relevant and contextualized UI definition:

1.  **`view_identifier` (string):**
    *   Specifies the type of view or page the user is requesting or transitioning to (e.g., "landingPage", "searchResultsView", "podcastPlayerView", "userProfilePage").
    *   This helps the DUIA select the appropriate high-level templates or generation strategies.

2.  **`content_payload` (object/array):**
    *   The primary data to be displayed, typically orchestrated by CPOA and passed to DUIA.
    *   Examples:
        *   For "landingPage": A list of snippet objects.
        *   For "searchResultsView": A list of search result snippet objects and the search query.
        *   For "podcastPlayerView": Details of the specific podcast, including GCS URIs for audio/image, script segments, etc.
        *   For error views: Error messages and codes.

3.  **`user_context` (object, optional):**
    *   Information about the user and their session, which can be used for personalization.
    *   Examples:
        *   User preferences (e.g., preferred theme, content categories, accessibility settings).
        *   Interaction history within the current session.
        *   Device type or capabilities (if detectable and passed by API Gateway).
        *   Authentication status and `user_id`.

4.  **`application_state` (object, optional):**
    *   Broader state information that might influence the UI.
    *   Examples:
        *   System-wide alerts or messages.
        *   Current loading states for different parts of the application.
        *   Feature flags or A/B testing variants active for the user.

### 4.2. Generation Strategies

The DUIA can employ several strategies to generate the UI Definition JSON:

1.  **Programmatic Construction (Recommended Initial Focus):**
    *   **Description:** This approach uses backend code (e.g., Python functions/classes) to construct the UI schema JSON. Specific functions would be responsible for generating different parts of the UI or different component types based on the input data and context.
    *   **Example (Conceptual Python Pseudocode):**
        ```python
        def build_snippet_card_component(snippet_data):
            # snippet_data contains title, summary, image_url (signed GCS URL)
            return {
                "type": "card",
                "props": {
                    "layout": {"direction": "column", "padding": "10px"},
                    "style": {"border": "1px solid #eee", "borderRadius": "8px"}
                },
                "children": [
                    {
                        "type": "image",
                        "props": {
                            "src": snippet_data.get("image_url"),
                            "alt_text": f"Cover art for {snippet_data.get('title')}",
                            "layout": {"height": "150px", "width": "100%"},
                            "style": {"objectFit": "cover"}
                        }
                    },
                    {
                        "type": "text",
                        "props": {"content": snippet_data.get("title"), "semantic_as": "h3", "style": {"fontSize": "1.1em"}}
                    },
                    {
                        "type": "text",
                        "props": {"content": snippet_data.get("summary"), "style": {"fontSize": "0.9em"}}
                    },
                    // ... button for "Listen Now" with onClick event ...
                ]
            }

        def build_snippet_list_ui(view_id, snippets_array_data, user_context):
            cards = [build_snippet_card_component(s) for s in snippets_array_data]
            return {
                "view_id": view_id,
                "schema_version": "1.0",
                "context_data": {"page_title": "Latest Snippets", ...user_context},
                "root_component": {
                    "type": "container",
                    "props": {"layout": {"direction": "column", "padding": "20px"}},
                    "children": [
                        {"type": "text", "props": {"content": "{view.context_data.page_title}", "semantic_as": "h1"}},
                        {
                            "type": "list_view",
                            "props": {
                                "data_source": "{view.context_data.raw_snippets}", // Assuming raw_snippets is passed in context_data
                                "item_template": build_snippet_card_component({
                                     # Illustrative; actual binding would be to item properties
                                     "title": "{item.title}", "summary":"{item.summary}", "image_url":"{item.image_url}"
                                 })
                                 // More realistically, item_template itself is a schema snippet
                                 // that uses {item.*} bindings, rather than calling a Python function here.
                                 // The Python function would generate the item_template schema once.
                            },
                            "children": cards // If not using data_source + item_template, but direct children
                        }
                    ]
                }
            }
        ```
    *   **Pros:** Full control over schema generation, type safety (if using typed languages/objects before serialization), easier debugging, good performance.
    *   **Cons:** Less "AI-first" for layout/style itself; changes require code deployment.

2.  **Rule-Based Generation (Future Possibility):**
    *   **Description:** A rules engine could define how UI structures or styles adapt based on context (e.g., "if user preference `condensed_view` is true, then use `layout_pattern_condensed` for lists"). Rules could be managed separately from code.
    *   **Pros:** More dynamic than pure programmatic construction without full LLM involvement.
    *   **Cons:** Complex rule sets can become hard to manage.

3.  **LLM-Driven UI Schema Generation (Advanced Future Possibility):**
    *   **Description:** An LLM is prompted with the content, context, and high-level UI goals, and it directly generates the UI Definition JSON. This aligns closely with the "AI-First Paradigm" (Requirement `01_...#1.1, #1.4`).
    *   **Pros:** Maximum dynamism; potential for novel and highly adaptive UIs.
    *   **Cons:**
        *   **Schema Adherence:** Ensuring LLM output strictly adheres to the defined JSON schema is a major challenge. Requires robust validation and potentially repair mechanisms.
        *   **Controllability & Predictability:** LLM outputs can be unpredictable.
        *   **Performance:** LLM inference time for generating complex UI schemas could be significant.
        *   **Debugging:** Debugging why an LLM generated a particular UI can be difficult.
        *   **Accessibility & Semantics:** Ensuring LLM-generated UIs are accessible and semantically correct is very hard.
    *   **Mitigation:** Start with LLMs generating specific *parts* of the schema (e.g., choosing a layout pattern from a predefined set, or suggesting style variations) rather than the entire structure from scratch.

The initial prototype for Aethercast will focus on **Programmatic Construction** for generating the UI Definition JSON, as it provides the most control and reliability for establishing the core functionality.

### 4.3. Interaction with CPOA Workflow & State

1.  **Invocation:** CPOA, after orchestrating content retrieval and processing (e.g., fetching snippets from SCA/IGA, getting search results), would invoke the DUIA logic (whether it's an internal CPOA module or a separate DUIA service).
2.  **Data Passing:** CPOA passes the necessary `view_identifier`, the `content_payload` (e.g., list of snippet data objects), and any relevant `user_context` or `application_state` to the DUIA logic.
3.  **UI Definition Return:** The DUIA logic returns the complete UI Definition JSON.
4.  **Response to API Gateway:** CPOA forwards this UI Definition JSON to the API Gateway, which then sends it to the frontend client.
5.  **State Storage (Considerations):**
    *   **Full UI JSON:** Storing the full UI Definition JSON in `workflow_instances.context_data_json` for every minor change or view is likely too verbose and inefficient, especially for large UI schemas.
    *   **Key UI Parameters/Decisions:** It might be more practical to store key parameters or decisions made by DUIA (or the rules/LLM it uses) within the `context_data_json` if they are important for understanding the workflow state or for potential future resumption/analysis (e.g., `{"ui_template_chosen": "condensed_snippet_view", "theme_applied": "dark_mode"}`).
    *   **No Storage (Default):** Initially, the UI Definition JSON can be considered ephemeral, generated on-demand and not stored directly in the workflow state tables, unless specific parts are needed for context. The raw *content* data that feeds into UI generation would already be part of task outputs.

### 4.4. API Contract (Conceptual for DUIA as a Separate Service)

If DUIA were implemented as a distinct microservice, its API might look like:

*   **Endpoint:** `POST /ui/generate_view`
*   **Request Body (JSON):**
    ```json
    {
        "view_identifier": "landingPage", // e.g., "landingPage", "searchResults", "podcastDetail"
        "content_payload": {
            "snippets": [ /* ... */ ],
            "search_query": "AI in art"
            // ... other content relevant to the view_identifier
        },
        "user_context": {
            "user_id": "user-123",
            "preferences": {"theme": "dark", "font_scale": 1.2},
            "device_info": {"viewport_width": 1920} // Optional
        },
        "application_state": {
            "is_loading_global_alert": false
        }
    }
    ```
*   **Success Response (200 OK):**
    *   Body: The UI Definition JSON (as per Section 3).
*   **Error Responses:**
    *   `400 Bad Request`: If `view_identifier` is missing or unsupported, or if `content_payload` is invalid for the given view.
        ```json
        {"error_code": "DUIA_INVALID_VIEW_ID", "message": "View identifier not recognized."}
        ```
    *   `500 Internal Server Error`: If DUIA encounters an internal error during UI schema generation.
        ```json
        {"error_code": "DUIA_GENERATION_ERROR", "message": "Failed to generate UI definition."}
        ```

This conceptual API helps define the DUIA's boundaries and expected data exchange, even if it's initially a module within CPOA.

## 5. Frontend Adaptation Requirements (Conceptual)

This section outlines the conceptual requirements and changes needed in the frontend application (primarily `aethercast/fend/app.js`) to parse, interpret, and render a user interface based on the UI Definition JSON received from the backend.

### 5.1. Core Rendering Logic

A fundamental shift in `app.js` will be the introduction of a schema-driven rendering engine. This engine will replace manual DOM manipulation for main content areas.

*   **Fetching and Parsing:**
    *   A new function (e.g., `fetchAndRenderView(viewId, apiParams)`) will be responsible for fetching the UI Definition JSON from a designated backend endpoint (e.g., `/api/v1/ui/view/{viewId}`).
    *   The fetched JSON will be parsed into a JavaScript object structure.
*   **Recursive Rendering Function:**
    *   A core recursive function (e.g., `renderComponent(componentSchema, dataContext, parentElement)`) will traverse the `root_component` tree from the UI definition.
    *   **Inputs:**
        *   `componentSchema`: The schema object for the current component.
        *   `dataContext`: The combined global `view.context_data` and any item-specific data (for list items).
        *   `parentElement`: The HTML DOM element to which the newly rendered component should be appended.
    *   **Process:**
        1.  Determine the HTML element type to create based on `componentSchema.type` and `componentSchema.props.semantic_as`.
        2.  Create the HTML element.
        3.  Apply `id` if present in the schema.
        4.  Apply layout and style properties from `componentSchema.props.layout` and `componentSchema.props.style` to the element's `style` attribute or class list.
        5.  Process and set content (e.g., text for a `text` component, `src` and `alt` for an `image`), resolving any data bindings using the `dataContext`.
        6.  Evaluate `props.visibility_condition`, if present, to determine if the component should be rendered.
        7.  Attach event listeners based on `componentSchema.props.events`.
        8.  Append the newly created element to `parentElement`.
        9.  If `componentSchema.children` exist, recursively call `renderComponent` for each child, passing the newly created element as the new `parentElement`.
*   **DOM Target:**
    *   A designated area in `index.html` (e.g., `<main id="dynamic-view-content"></main>`) will serve as the mounting point for the dynamically rendered UI. This area will be cleared before rendering a new view.

### 5.2. Handling Component Types (Examples)

The rendering engine will have specific logic for each component type defined in the schema:

*   **`container`**: Renders as a `div` (or `section`, `article`, etc., based on `semantic_as`). Applies flexbox/layout styles. Recursively renders children.
*   **`text`**: Renders as `p`, `h1`-`h6`, `span`, etc. Sets `textContent` after resolving data bindings. Applies text-specific styles.
*   **`image`**: Renders as an `img` tag. Sets `src` and `alt` after resolving data bindings. Applies layout (width/height) and styles (object-fit).
*   **`button`**: Renders as a `button` tag. Sets label (resolving bindings). Attaches `onClick` (and other) event listeners. Applies button-specific styling/variants.
*   **`list_view`**:
    *   Resolves its `data_source` property to get an array from the `dataContext`.
    *   If the array is empty and `empty_state_component` is defined, renders that component.
    *   Otherwise, iterates through the array. For each item in the array:
        *   Creates a new data context by augmenting the parent `dataContext` with the current `item` (e.g., `loopContext = { ...dataContext, item: currentItemData }`).
        *   Recursively calls the rendering engine for `props.item_template`, passing this `loopContext`.
*   **`card`**: Similar to `container`, often used as an `item_template` in `list_view`.
*   **`input_field`**: Renders as an `input` tag. Sets `type`, `placeholder`, and `value` (resolving bindings). Implements two-way data binding by updating the `view.context_data` path specified in `bind_to_context` on user input, and listening for changes to that context path to update its value.
*   **`spacer`**: Renders an empty `div` with specified dimensions (height/width) for spacing.

### 5.3. Data Binding on Frontend

*   A utility function (e.g., `resolveBinding(templateString, dataContext)`) will be crucial.
*   This function will take a string from the schema (e.g., `"{view.context_data.user.name}"` or `"{item.title}"`) and the current `dataContext`.
*   It will parse the binding path (e.g., `view.context_data.user.name`) and traverse the `dataContext` object to retrieve the corresponding value.
*   This resolved value will then be used to set element content, attributes, or evaluate conditions.
*   For `input_field`'s `bind_to_context`, the renderer will also need to update the `dataContext` when the input's value changes and potentially trigger a re-render of dependent components if not handled by a more sophisticated reactivity system.

### 5.4. Event Handling

*   The rendering engine will map `props.events` (e.g., `onClick`) to JavaScript event listeners.
*   The callback for these listeners will execute actions based on `action_type`:
    *   **`API_CALL`**:
        *   Construct the request body/params from `payload_template`, resolving any data bindings from `dataContext`.
        *   Use existing or new helper functions in `app.js` to make the HTTP request.
        *   Handle responses, potentially triggering further actions defined in `response_actions` (e.g., updating context, showing a message).
    *   **`NAVIGATE`**:
        *   Resolve the `target_path` (which might include data bindings).
        *   Interact with a client-side router (if one is implemented) or directly use `window.location` or `fetchAndRenderView` for the new path.
    *   **`UPDATE_CONTEXT_DATA`**:
        *   Modify a client-side JavaScript object representing the `view.context_data`.
        *   If `trigger_rerender` is true (default), the main rendering function or a more targeted update mechanism would be invoked to reflect changes in the UI.
    *   **`SHOW_MODAL`**:
        *   Locate the modal element (likely predefined in `index.html` or also dynamically rendered if its schema is provided).
        *   Update its content/state using `modal_context` (resolving bindings).
        *   Display the modal.
    *   **`CUSTOM_EVENT`**:
        *   Dispatch a JavaScript CustomEvent with `event_name` and resolved `event_data`. Other parts of `app.js` could listen for these events to perform custom actions.

### 5.5. Impact on Existing `app.js` Structure

*   **Significant Refactor:** This is a major architectural change for `app.js`. Large portions of code currently responsible for directly creating and updating HTML elements for snippets, search results, etc., will be replaced by the generic schema rendering engine.
*   **Centralized Rendering:** UI generation logic moves from many specific functions to one generalized engine.
*   **State Management:** `view.context_data` becomes a central piece of client-side state for the current view, managed and updated as per schema instructions or event handlers.
*   **API Call Abstraction:** Functions like `fetchAndRenderSnippets()` would likely be replaced by `fetchAndRenderView('landingPage')`. The backend would then provide the UI schema, including any necessary data within its `context_data`. Specific API calls for actions (like subscribe, play) would be triggered by event handlers defined *within* the schema.
*   **WebSocket Integration:** WebSocket handlers would need to change. Instead of direct DOM manipulation, they might:
    1.  Receive data that updates `view.context_data`, triggering a re-render of affected components.
    2.  Receive instructions to fetch a new UI definition for the entire view or a part of it.
    3.  Receive a partial UI schema to patch the existing view (more advanced).

### 5.6. Key Challenges

*   **Complexity of Renderer:** Building a robust and comprehensive rendering engine that correctly handles all component types, properties, data bindings, and event actions is complex.
*   **Performance:**
    *   Deeply nested schemas or large lists could lead to performance bottlenecks during rendering.
    *   Efficiently re-rendering only affected parts of the UI upon `UPDATE_CONTEXT_DATA` actions (rather than re-rendering the entire view) is crucial and might require a virtual DOM-like approach or careful targeted updates if built from scratch.
*   **Styling Strategy:**
    *   Managing styles effectively (inline styles from schema vs. `customCssClass` vs. global CSS) needs a clear strategy to avoid conflicts and maintain consistency.
    *   Ensuring responsiveness based on schema properties requires careful translation to CSS.
*   **Accessibility (A11y):** While the schema includes `semantic_as` and `alt_text`, ensuring the generated HTML is fully accessible (e.g., correct ARIA attributes, keyboard navigation for custom components) requires diligent implementation in the renderer.
*   **Debugging:** Debugging issues in a dynamically generated UI can be harder. Tools for inspecting the current `componentSchema` and `dataContext` alongside the rendered DOM would be helpful.
*   **Expression Evaluation:** Safely evaluating expressions in `visibility_condition` or for complex data updates in `onClick` handlers requires a controlled parser/evaluator to prevent security risks if these expressions become too powerful or user-influenced.
*   **Two-Way Data Binding for Inputs:** Implementing robust two-way data binding for `input_field` components (updating context on input, and updating input value on context change) requires careful state management and event handling.

---

*For information on the overarching Aethercast project architecture, advanced setup including database migrations for shared resources like idempotency tables, and how services interact, please refer to the main [README.md](../../../README.md) at the root of the Aethercast project.*
